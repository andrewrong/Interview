
### 将整型转化为罗马数字

这个题目我做了很久，而且最后看似成功，可是还是有小部分例子通不过，那个时候已经是凌晨12:00多了，所以心里特别着急，平时我都挺早睡觉的，由于情绪的影响导致最后的程序越改越离谱，解决了这边的意外，那边本来好好的例子就出现问题了，最后我就放弃了，想想明天早上再做吧。第二天早上果然一下子就做出来了;就只需改一个小小的地方就ok了...昨天还花了我1个小时去修改...发现越是到最后就越要冷静，绝对不能着急.

####1. 程序的关键点

首先google了一下Roman数字的基本概念和组成方式,基本上Roman数字有7个符号来表示，分别是

>1  5	10  50	100 500	1000
>I  V	X   L	C   D	M

这就是罗马数字的7个符号，其他的数字基本上就靠这些符号构成的.我的**思路**:对输入的整数(input)进行从高到低的除，如果商不是0，那么就用相应的数字来表示;比如 *11,11被10除了以后商为1，那么就是X,而input减去相应的数就得到了1,那么再按刚才的思路往下做下去,1能被1除，所以就多了一个I,这样就知道11是XI来表示*，基本上的思路就是这样的，接下来就是要处理几种特殊情况;

在讲特殊情况前，先讲一下关于Roman数字的几个我要用到的特殊规则:

1. 连续重复的数字不能超过3,如果超过3了，那就使用大数减一个小数,比如3=III，4=IV

2. 在左边能用来被减的数是有限制的,只能是I、X、C，也就是说V、L、D都不能放在左边当作减数;比如45 = XLV 而不是 VL

3. 在Roman中能重复的数字也是有限制的，比如90 = XC，而不是LXL，能重复出现的处理就只能是I、X、C

看来Roman对于5相关的数字都比较讨厌，对它的限制最多了;

基于上面的条款，特殊情况就已经限定在一些比较小范围的数了,比如1. 9,19,29....,2. 90+,900+....,3. 45+,450+....

我是这么去处理这几种情况的:

1. 对于2,3两种情况的话,主要是通过比较一下是不是比上面的某一个数的0.9大,如果成立的话,那么就是2 or 3这两种情况中的一种.这样就可以对特殊情况进行特殊处理了;

比如:
> 1.现在我是95,当除以100的时候，我们发现95 \> 0.9*(100),那就进入了2 or 3两种情况中的一种的,这个时候开始判断100是不是被限制的符号，显然不是，所以就变成了第二种情况,那么就直接当一种固定的模式处理,这个时候就出现XC,然后让95-90 = 5,然后让5继续让下运行下去，最后的结果就是XCV了;

>2. 如果是46呢,以上面的趋势，我们进入了2 or 3两种情况中的一种，然后判断了它是属于第3种情况的,这个时候也以固定模式变成XL，然后46 - 40 = 6，让6继续往下运行下去;

基本上处理了上面的两个特殊例子也差不多了,但是我没有考虑到19这种特殊情况;因为我处理条件1,所以如果我们的商是大于3的话，我们就要使用减法来处理这个问题,那么我想如果小于等于3就直接把字符加上就ok了，如果大于3的话，就直接让前面的字符减去当前的字符，比如4，它的商是4,那么当前的字符是'I',那么4=IV来表示;关键的错误是我在处理上上面这个过程以后，我又让遍历在7个字符中的指针往后面移动了一格;我已经都说不清了,反正就是情况考虑的不周全，导致很多时间花在调试上面了;

####2. 总结

对于这次做题，我的感受是在考虑的过程中，要把你认为的例外都很好的记录下来，然后在你写完程序以后可以让这些例子在你的大脑中跑一下，看看会不会有哪些地方你想没有做的很好的，还有就是不要着急，越着急越办不好事情的
